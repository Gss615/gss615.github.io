<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<link rel="stylesheet" href="/css/index.css">

  
<link rel="stylesheet" href="/css/highlight/styles/atom-one-light.css">

  
<link rel="stylesheet" href="/css/fontawesome/all.min.css">

  
    <link rel="icon" href="/images/javascript-color.png">
  
  <title>前端笔记</title>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="前端笔记" type="application/atom+xml">
</head>


<!--config 在根目录下 _config.yml 中配置-->


<body>
<section class="main">
    <!--文章-->
<section class="container">
    <h1 style="text-align: center;"><a href="#">递归</a></h1>
<p style="overflow: hidden;">
    <!-- 可以写时间，还没想好 -->
     
</p>


    <hr>
    
        <mian>
            <aside class="sidebar">
    <h3>目录</h3>
    
    <div class="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是递归"><span class="toc-text">什么是递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归中的调用栈"><span class="toc-text">递归中的调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧和思路"><span class="toc-text">技巧和思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#练习题"><span class="toc-text">练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#阶乘"><span class="toc-text">阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#青蛙跳台阶问题"><span class="toc-text">青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#翻转二叉树"><span class="toc-text">翻转二叉树</span></a></li></ol></li></ol>
    </div>

</aside>
            <article>
                <h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote>
<p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p>
</blockquote>
<p>在JavaScript中是指在函数定义中使用函数自身的方法。</p>
<ul>
<li>直接调用自己</li>
<li>间接调用自己</li>
</ul>
<pre><code class="javascript">function foo(){
    foo()
}</code></pre>
<p>每个递归函数都有两个部分：基线条件和递归条件。递归条件是指函数调用自己，而基线条件是指函数不再调用自己，从而避免形成无限循环。</p>
<h2 id="递归中的调用栈"><a href="#递归中的调用栈" class="headerlink" title="递归中的调用栈"></a>递归中的调用栈</h2><p>栈是一种后进先出的数据结构。</p>
<p>示例：</p>
<pre><code class="javascript">function foo(i) {
  if (i &lt; 0) return;
  console.log(&#39;begin:&#39; + i);
  foo(i - 1);
  console.log(&#39;end:&#39; + i);
}
foo(2);</code></pre>
<details>
  <summary>打印</summary>
  <pre>
    begin 2
    begin 1
    begin 0
    end 0
    end 1
    end 2
  </pre>
</details>

<p>每当一个函数被一个算法调用时，该函数会进入调用栈的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果；可以将 <code>console.trace</code> 添加到函数头部在控制台中查看。</p>
<pre><code class="javascript">function foo(i) {
    console.trace()
    if (i &lt; 0) return;
    console.log(&#39;begin:&#39; + i);
    foo(i - 1);
    console.log(&#39;end:&#39; + i);
}
foo(2);</code></pre>
<details>
<summary>打印</summary>
<pre>
<code>
recursion.js:67 console.trace
foo @ recursion.js:67
(anonymous) @ recursion.js:73
recursion.js:69 begin:2
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:69 begin:1
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:69 begin:0
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
foo @ recursion.js:70
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:71 end:0
recursion.js:71 end:1
recursion.js:71 end:2
</code>
</pre>
</details>

<p>如果递归函数中用到大量数据，或者调用栈很长，可以能会造成栈占用大量内存，解决的办法有两个：</p>
<ul>
<li>重新编写代码，使用循环</li>
<li>使用尾递归</li>
</ul>
<h2 id="技巧和思路"><a href="#技巧和思路" class="headerlink" title="技巧和思路"></a>技巧和思路</h2><blockquote>
<ol>
<li>先定义一个函数，明确这个函数的功能</li>
<li>寻找问题和自问题间的关系，也就是递推关系</li>
<li>寻找最终不可再分解的子问题，也就是临界值</li>
<li>根据问题和子问题的关系，推导时间复杂</li>
</ol>
</blockquote>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><ol>
<li><p>定以函数</p>
<pre><code class="javascript"> function factorial(n){
 // TODO 计算
 }</code></pre>
</li>
<li><p>寻找递推关系</p>
<p> 这个函数的功能是求n的阶乘，也就是 1 到 n 所有数的乘积<br> $$f(n) = n * (n - 1) * (n - 2) * (n - 3) * … * 1$$<br> 很容易看出 f(n) 和 f(n-1) 的关系为：<br> $$f(n) = f(n-1) * n$$</p>
</li>
<li><p><strong>寻找临界值</strong></p>
<p> 阶乘不能有0，最小值为1，1的乘积还是为1<br> $$f(1) = 1$$<br> 得出结论：<br> $$<br> f(n)=\begin{cases}<br> 1,\quad n = 1 \\<br> f(n-1) * n,\quad n &gt; 1<br> \end{cases}<br> $$<br> 将结论转换为代码：</p>
<pre><code class="javascript"> function factorial(n){
     if(n === 1) return 1
     return factorial(n - 1) * n
 }</code></pre>
</li>
<li><p>时间复杂度</p>
<p> 总共有n个子问题 O(n)；<br> 每个问题进行了一次计算 O(1)；<br> 时间复杂度为 O(n)</p>
</li>
</ol>
<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>提示：0 &lt;= n &lt;= 100</p>
<ol>
<li><p>定义函数 climbStairs</p>
<pre><code class="javascript">function climbStairs(n){
 // TODO
}</code></pre>
</li>
<li><p>寻找递推关系</p>
<p>假设跳上 n 级台阶有f(n)种跳法，在所有跳法中，青蛙的最后一步只有两种情况：跳了 1 阶或跳了 2 阶</p>
<ol>
<li>当为 1 阶台阶：剩 n - 1 个台阶，这种情况共有 f(n - 1) 种跳法；</li>
<li>当为 2 阶台阶：剩 n - 2 个台阶，这种情况共有 f(n - 2) 种跳法。</li>
</ol>
<p>f(n) 为以上两种情况当和，得出结论为:</p>
<p>$$f(n) = f(n - 1） + f(n - 2)$$</p>
</li>
<li><p>寻找临界值</p>
<p>n 为 0 时，f(0) = 1</p>
<p>n 为 1 时，f(1) = 1<br>$$<br>f(n)=\begin{cases}<br>1,\quad n = 0 \\<br>1,\quad n = 1 \\<br>f(n-1) + f(n-2),\quad n &gt; 2<br>\end{cases}<br>$$<br>将结论转换为代码</p>
<pre><code class="javascript">functionn climbStairs(n){
  if(n === 0 || n === 1) return 1
  return f(n - 1) + f(n - 2)
}</code></pre>
</li>
<li><p>空间复杂度</p>
<p>子问题个数：climbStairs 算法形成了一个递归数，每个问题是一个节点，当前节点下形成两个节点，所以子问题的个数为O(2^n)；<br>解决一个问题的时间：递归中，每次只执行了 一个加法计算，时间为O(1)<br>所以这个算法的时间复杂度为O(2^n)，为指数级别，不可取。</p>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/" target="_blank" rel="noopener">另外还有两种方法</a></p>
<ul>
<li>记忆法递归<br>   原理：在递归法的基础上，新建一个长度为 n 的数组，用于在递归时储存f(0)到f(n)的数字只，重复遇到某数字时直接从数组取用，避免重复计算。但记忆储存需要O(n)的额外空间</li>
<li>动态规划<br>   以斐波那契数列性质f(n+1) = f(n) + f(n-1)为转移方程。</li>
</ul>
</li>
</ol>
<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h3><ol>
<li><p>定义函数 treeNode</p>
<pre><code>```javascript
function treeNode(tree){
    // TODO
}
```</code></pre></li>
<li><p>寻找递推关系</p>
<p> 假设解决root节点的反转为 treeNode(root)；</p>
<pre><code class="javascript"> treeNode(node){
     let left = node.right
     let right = node.left
     node.right = left
     node.left = right
     return node
  }</code></pre>
<p> root节点又分为left，right两个节点，这两个节点分别产生两个节点，也都需要反转，子问题的子问题也是如此.</p>
<pre><code class="javascript"> treeNode(node){
     let left = node.right
     let right = node.left
     node.right = treeNode(node.left)
     node.left = treeNode(node.right)
     return node
  }</code></pre>
</li>
<li><p>寻找临界值</p>
<p> 如果父节点下面有子节点是，就需要反转；如果为 null 时，也就是连一个子节点都没有，也就不需要反转了。</p>
<pre><code class="javascript"> treeNode(node){
     if(node === null) return node
     let left = node.right
     let right = node.left
     node.right = treeNode(node.left)
     node.left = treeNode(node.right)
     return node
  }</code></pre>
</li>
<li><p>时间复杂度</p>
<p> 树的每个节点都只被访问一次，时间复杂度为 O(n)</p>
</li>
</ol>
<blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Leetcode</a></li>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode</a></li>
<li><a href="https://www.cxyxiaowu.com/7259.html" target="_blank" rel="noopener">告别递归，从零开始一文学会递归解题</a></li>
</ul>
</blockquote>

            </article>
        </mian>
    
</section>
<footer class="post-footer">
    <p>
        <a href="/"><i class="fa fa-home"></i></a> |
        <a href="https://github.com/Gss615/blog/edit/master/source/_posts/递归.md" target="_self"><i class="fas fa-code"></i> 编辑</a>｜
        <a href="https://github.com/Gss615/blog/commits/master/source/_posts/递归.md" target="_self"><i class="fas fa-history"></i> 历史</a>｜
        <span>最后更新时间：<span>2020-05-11</span></span>
    </p>
</footer>

</section>


<script src="/js/highlight.pack.js"></script>
 

<script src="/js/script.js"></script>
 
<!-- <script>hljs.initHighlightingOnLoad();</script> -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>