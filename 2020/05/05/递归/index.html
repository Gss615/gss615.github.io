<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<link rel="stylesheet" href="/css/index.css">

  
<link rel="stylesheet" href="/css/highlight/styles/atom-one-light.css">

  
<link rel="stylesheet" href="/css/fontawesome/all.min.css">

  
    <link rel="icon" href="/images/javascript-color.png">
  
  <title>前端笔记</title>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="前端笔记" type="application/atom+xml">
</head>


<!--config 在根目录下 _config.yml 中配置-->


<body>
<section class="main">
    <!--文章-->
<section class="container">
    <h1 style="text-align: center;"><a href="#">递归</a></h1>
<p style="overflow: hidden;">
    <!-- 可以写时间，还没想好 -->
     
</p>


    <hr>
    
        <mian>
            <aside class="sidebar">
    <h3>目录</h3>
    
    <div class="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是递归"><span class="toc-text">什么是递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归中的调用栈"><span class="toc-text">递归中的调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技巧和思路"><span class="toc-text">技巧和思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-text">示例</span></a></li></ol>
    </div>

</aside>
            <article>
                <h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote>
<p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p>
</blockquote>
<p>在JavaScript中是指在函数定义中使用函数自身的方法。</p>
<ul>
<li>直接调用自己</li>
<li>间接调用自己</li>
</ul>
<pre><code class="javascript">function foo(){
    foo()
}</code></pre>
<p>每个递归函数都有两个部分：基线条件和递归条件。递归条件是指函数调用自己，而基线条件是指函数不再调用自己，从而避免形成无限循环。</p>
<h2 id="递归中的调用栈"><a href="#递归中的调用栈" class="headerlink" title="递归中的调用栈"></a>递归中的调用栈</h2><p>栈是一种后进先出的数据结构。</p>
<p>示例：</p>
<pre><code class="javascript">function foo(i) {
  if (i &lt; 0) return;
  console.log(&#39;begin:&#39; + i);
  foo(i - 1);
  console.log(&#39;end:&#39; + i);
}
foo(2);</code></pre>
<details>
  <summary>打印</summary>
  <pre>
    begin 2
    begin 1
    begin 0
    end 0
    end 1
    end 2
  </pre>
</details>

<p>每当一个函数被一个算法调用时，该函数会进入调用栈的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果；可以将 <code>console.trace</code> 添加到函数头部在控制台中查看。</p>
<pre><code class="javascript">function foo(i) {
    console.trace()
    if (i &lt; 0) return;
    console.log(&#39;begin:&#39; + i);
    foo(i - 1);
    console.log(&#39;end:&#39; + i);
}
foo(2);</code></pre>
<details>
<summary>打印</summary>
<pre>
<code>
recursion.js:67 console.trace
foo @ recursion.js:67
(anonymous) @ recursion.js:73
recursion.js:69 begin:2
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:69 begin:1
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:69 begin:0
recursion.js:67 console.trace
foo @ recursion.js:67
foo @ recursion.js:70
foo @ recursion.js:70
foo @ recursion.js:70
(anonymous) @ recursion.js:73
recursion.js:71 end:0
recursion.js:71 end:1
recursion.js:71 end:2
</code>
</pre>
</details>

<p>如果递归函数中用到大量数据，或者调用栈很长，可以能会造成栈占用大量内存，解决的办法有两个：</p>
<ul>
<li>重新编写代码，使用循环</li>
<li>使用尾递归</li>
</ul>
<h2 id="技巧和思路"><a href="#技巧和思路" class="headerlink" title="技巧和思路"></a>技巧和思路</h2><blockquote>
<ol>
<li>先定义一个函数，明确这个函数的功能</li>
<li>寻找问题和自问题间的关系，也就是递推关系</li>
<li>寻找最终不可再分解的子问题，也就是临界值</li>
<li>根据问题和子问题的关系，推导时间复杂</li>
</ol>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>任何大于1的自然数n阶乘<br>用递归实现阶乘 1*2*3<em>…</em>9</p>
<ol>
<li><p>定以函数</p>
<pre><code class="javascript">function factorial(n){
// 待写逻辑
}</code></pre>
<p>这个函数的功能是求1 到 n 所有数的乘积，也就是n的阶乘，用伪代码实现就是：</p>
<p>n * (n - 1) * (n - 2) * (n - 3) * … * 1)</p>
</li>
<li><p>寻找递推关系<br>f(n) = n * (n - 1) * (n - 2) * (n - 3) * … * 1<br>f(n - 1) = (n - 1) * (n - 2) * (n - 3) * … * 1<br>得出问题和子问题的关系为：<br>f(n) = n * f(n -1)</p>
<pre><code class="javascript">function factorial(n){
 return factorial(n - 1) * n
}</code></pre>
</li>
<li><p>寻找临界值<br>阶乘不能有0，最小值为1，1的乘积还是为1</p>
<pre><code class="javascript">function factorial(n){
 if(n === 1) return 1
 return factorial(n - 1) * n
}</code></pre>
</li>
<li><p>时间复杂度<br>// …</p>
</li>
</ol>
<p>TODO 树中到递归</p>
<p>求二叉树的最大深度<br>Simple inline $$a = b + c$$.<br>Simple inline $a = b + c$.</p>
<hr>
<p> \(a+b=c\)</p>

            </article>
        </mian>
    
</section>
<footer class="post-footer">
    <p>
        <a href="/"><i class="fa fa-home"></i></a> |
        <a href="https://github.com/Gss615/blog/edit/master/source/_posts/递归.md" target="_self"><i class="fas fa-code"></i> 编辑</a>｜
        <a href="https://github.com/Gss615/blog/commits/master/source/_posts/递归.md" target="_self"><i class="fas fa-history"></i> 历史</a>｜
        <span>最后更新时间：<span>2020-05-10</span></span>
    </p>
</footer>

</section>


<script src="/js/highlight.pack.js"></script>
 

<script src="/js/script.js"></script>
 
<!-- <script>hljs.initHighlightingOnLoad();</script> -->

</body>
</html>