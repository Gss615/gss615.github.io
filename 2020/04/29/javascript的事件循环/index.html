<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<link rel="stylesheet" href="/css/index.css">

  
<link rel="stylesheet" href="/css/highlight/styles/atom-one-light.css">

  
<link rel="stylesheet" href="/css/fontawesome/all.min.css">

  
    <link rel="icon" href="/images/javascript-color.png">
  
  <title>前端笔记</title>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="前端笔记" type="application/atom+xml">
</head>


<!--config 在根目录下 _config.yml 中配置-->


<body>
<section class="main">
    <!--文章-->
<section class="container">
    <h1 style="text-align: center;"><a href="#">JavaScript的事件循环</a></h1>
<p style="overflow: hidden;">
    <!-- 可以写时间，还没想好 -->
     
</p>


    <hr>
    
        <mian>
            <aside class="sidebar">
    <h3>目录</h3>
    
    <div class="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用栈"><span class="toc-text">调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列（Callback-Queue）"><span class="toc-text">队列（Callback Queue）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件循环（Event-Loop）"><span class="toc-text">事件循环（Event-Loop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#微任务与宏任务"><span class="toc-text">微任务与宏任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#练习题"><span class="toc-text">练习题</span></a></li></ol>
    </div>

</aside>
            <article>
                <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。</p>
<p>但是引擎实际上只做了几件事，它逐行运行代码，并将函数添加到堆栈中。</p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈是一个LIFO队列，即后进先出（Last in,First out）。</p>
<p>当调用一个函数时，它会被推入调用栈中。如果该函数调用另一个函数，另一个函数将位于调用栈的顶部，而这个函数执行完后 ，它会从栈中被推出，直到栈被清空。</p>
<p>示例</p>
<pre><code class="javascript">function foo(b) {
  let a = 10;
  return a + b + 11;
}

function bar(x) {
  let y = 3;
  return foo(x * y);
}

console.log(bar(7)); // 返回 42
</code></pre>
<ul>
<li>执行 <code>bar</code>，并推入栈中</li>
<li>执行 <code>bar</code> 时导致 <code>foo</code> 被调用</li>
<li>执行 <code>foo</code>，将 <code>foo</code> 推入栈中</li>
<li>执行完 <code>foo</code>，发现 <code>foo</code> 没有什么事情可做了，将 <code>foo</code> 推出栈</li>
<li><code>bar</code> 执行完毕，推出栈</li>
</ul>
<h2 id="队列（Callback-Queue）"><a href="#队列（Callback-Queue）" class="headerlink" title="队列（Callback Queue）"></a>队列（Callback Queue）</h2><p>Web APIs 提供了setTimeout，DOM事件等api。</p>
<p>在调用setTimeout时，浏览器会启用计时器，可以理解为这是浏览器做的；一旦计时器到期，将回调函数放入CallBack Queue中，并等待执行。Ajax，DOM事件等也在这里排队。</p>
<h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event-Loop）"></a>事件循环（Event-Loop）</h2><p><img src="/images/javascript-event-loop.png" alt=""></p>
<p>有一个过程会不断检查调用栈是否为空，并且每当它为空时，它就会检查 Callback Queue 中是否有等待调用的函数。如果有的话，那么队列中的第一个函数将被调用并将其移入调用栈。如果回调队列为空，则此监视过程将无限期地继续运行。事件循环是一个持续运行的过程，它同时监视回调队列和调用栈。</p>
<h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>ECMAScript 2015 引入了 Job Queue 的概念，Promise使用了这个队列，也是我们说的微任务。</p>
<p>前面 Callback Queue 中添加的任务可以被称为宏任务。</p>
<p>微任务优先级高于宏任务。</p>
<pre><code class="javascript">console.log(&#39;script start&#39;);
setTimeout(function() {
   console.log(&#39;setTimeout&#39;);
}, 0);
var promise = new Promise(function(resolve, reject) {
   resolve();
});
promise.then(function(resolve) {
   console.log(&#39;Promise1&#39;);
})
.then(function(resolve) {
   console.log(&#39;Promise2&#39;);
});
console.log(&#39;script end&#39;);</code></pre>
<details>
  <summary>打印</summary>
  <pre>
  script start
  script end
  Promise1
  Promise2
  setTimeout
  </pre>
</details>

<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>一</p>
<pre><code class="javascript">setTimeout(() =&gt; console.log(&#39;setTimeout1&#39;), 0);  
setTimeout(() =&gt; {                                                                
    console.log(&#39;setTimeout2&#39;);
    Promise.resolve().then(() =&gt; {
        console.log(&#39;promise3&#39;);
        Promise.resolve().then(() =&gt; {
            console.log(&#39;promise4&#39;);
        })
        console.log(5)
    })
    setTimeout(() =&gt; console.log(&#39;setTimeout4&#39;), 0);  
}, 0);
setTimeout(() =&gt; console.log(&#39;setTimeout3&#39;), 0);  
Promise.resolve().then(() =&gt; {
    console.log(&#39;promise1&#39;);
})</code></pre>
<p>二</p>
<pre><code class="javascript">async function async1() {
    console.log( &#39;async1 start&#39; )
    await async2()
    console.log( &#39;async1 end&#39; )
}
async function async2() {
    console.log( &#39;async2&#39; )
}
async1()
console.log( &#39;script start&#39; )</code></pre>
<p>三</p>
<pre><code class="javascript">async function async1() {
    console.log( &#39;async1 start&#39; )
await async2()
    console.log( &#39;async1 end&#39; )
}
async function async2() {
    console.log( &#39;async2&#39; )
}
console.log( &#39;script start&#39; )
setTimeout( function () {
    console.log( &#39;setTimeout&#39; )
}, 0 )
async1();
new Promise( function ( resolve ) {
    console.log( &#39;promise1&#39; )
    resolve();
} ).then( function () {
    console.log( &#39;promise2&#39; ) 
} )
console.log( &#39;script end&#39; )</code></pre>
<p>四</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt; {
    console.log(&quot;promise1&quot;)
    resolve()
})
    .then(() =&gt; {
        console.log(1)
    })
    .then(() =&gt; {
        console.log(2)
    })
    .then(() =&gt; {
        console.log(3)
    })

new Promise((resolve, reject) =&gt; {
    console.log(&quot;promise2&quot;)
    resolve()
})
    .then(() =&gt; {
        console.log(4)
    })
    .then(() =&gt; {
        console.log(5)
    })
    .then(() =&gt; {
        console.log(6)
    })</code></pre>
<p>五</p>
<pre><code class="javascript">async function t1 () {
  console.log(1)
  console.log(2)
  await Promise.resolve().then(() =&gt; console.log(&#39;t1p&#39;))
  console.log(3)
  console.log(4)
}

async function t2() {
  console.log(5)
  console.log(6)
  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))
  console.log(7)
  console.log(8)
}

t1()
t2()    </code></pre>
<p>六</p>
<pre><code class="javascript">async function t1 () {
  console.log(1)
  console.log(2)
  await new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      console.log(&#39;t1p&#39;)
      resolve()
    }, 1000)
  })
  await console.log(3)
  console.log(4)
}

async function t2() {
  console.log(5)
  console.log(6)
  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))
  console.log(7)
  console.log(8)
}

t1()
t2()

console.log(&#39;end&#39;)</code></pre>
<blockquote>
<p>参考：</p>
<p><a href="https://www.javascripttutorial.net/javascript-event-loop/" target="_blank" rel="noopener">https://www.javascripttutorial.net/javascript-event-loop/</a></p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
<p><a href="https://www.cnblogs.com/fangdongdemao/p/10262209.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangdongdemao/p/10262209.html</a></p>
</blockquote>

            </article>
        </mian>
    
</section>
<footer class="post-footer">
    <p>
        <a href="/"><i class="fa fa-home"></i></a> |
        <a href="https://github.com/Gss615/blog/edit/master/source/_posts/javascript的事件循环.md" target="_self"><i class="fas fa-code"></i> 编辑</a>｜
        <a href="https://github.com/Gss615/blog/commits/master/source/_posts/javascript的事件循环.md" target="_self"><i class="fas fa-history"></i> 历史</a>｜
        <span>最后更新时间：<span>2020-05-03</span></span>
    </p>
</footer>

</section>


<script src="/js/highlight.pack.js"></script>
 

<script src="/js/script.js"></script>
 
<!-- <script>hljs.initHighlightingOnLoad();</script> -->

</body>
</html>