<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-10T05:29:26.074Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>递归</title>
    <link href="http://yoursite.com/2020/05/05/%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2020/05/05/%E9%80%92%E5%BD%92/</id>
    <published>2020-05-05T15:30:31.000Z</published>
    <updated>2020-05-10T05:29:26.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p></blockquote><p>在JavaScript中是指在函数定义中使用函数自身的方法。</p><ul><li>直接调用自己</li><li>间接调用自己</li></ul><pre><code class="javascript">function foo(){    foo()}</code></pre><p>每个递归函数都有两个部分：基线条件和递归条件。递归条件是指函数调用自己，而基线条件是指函数不再调用自己，从而避免形成无限循环。</p><h2 id="递归中的调用栈"><a href="#递归中的调用栈" class="headerlink" title="递归中的调用栈"></a>递归中的调用栈</h2><p>栈是一种后进先出的数据结构。</p><p>示例：</p><pre><code class="javascript">function foo(i) {  if (i &lt; 0) return;  console.log(&#39;begin:&#39; + i);  foo(i - 1);  console.log(&#39;end:&#39; + i);}foo(2);</code></pre><details>  <summary>打印</summary>  <pre>    begin 2    begin 1    begin 0    end 0    end 1    end 2  </pre></details><p>每当一个函数被一个算法调用时，该函数会进入调用栈的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果；可以将 <code>console.trace</code> 添加到函数头部在控制台中查看。</p><pre><code class="javascript">function foo(i) {    console.trace()    if (i &lt; 0) return;    console.log(&#39;begin:&#39; + i);    foo(i - 1);    console.log(&#39;end:&#39; + i);}foo(2);</code></pre><details><summary>打印</summary><pre><code>recursion.js:67 console.tracefoo @ recursion.js:67(anonymous) @ recursion.js:73recursion.js:69 begin:2recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:69 begin:1recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:69 begin:0recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70foo @ recursion.js:70foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:71 end:0recursion.js:71 end:1recursion.js:71 end:2</code></pre></details><p>如果递归函数中用到大量数据，或者调用栈很长，可以能会造成栈占用大量内存，解决的办法有两个：</p><ul><li>重新编写代码，使用循环</li><li>使用尾递归</li></ul><h2 id="技巧和思路"><a href="#技巧和思路" class="headerlink" title="技巧和思路"></a>技巧和思路</h2><blockquote><ol><li>先定义一个函数，明确这个函数的功能</li><li>寻找问题和自问题间的关系，也就是递推关系</li><li>寻找最终不可再分解的子问题，也就是临界值</li><li>根据问题和子问题的关系，推导时间复杂</li></ol></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>任何大于1的自然数n阶乘<br>用递归实现阶乘 1*2*3<em>…</em>9</p><ol><li><p>定以函数</p><pre><code class="javascript">function factorial(n){// 待写逻辑}</code></pre><p>这个函数的功能是求1 到 n 所有数的乘积，也就是n的阶乘，用伪代码实现就是：</p><p>n * (n - 1) * (n - 2) * (n - 3) * … * 1)</p></li><li><p>寻找递推关系<br>f(n) = n * (n - 1) * (n - 2) * (n - 3) * … * 1<br>f(n - 1) = (n - 1) * (n - 2) * (n - 3) * … * 1<br>得出问题和子问题的关系为：<br>f(n) = n * f(n -1)</p><pre><code class="javascript">function factorial(n){ return factorial(n - 1) * n}</code></pre></li><li><p>寻找临界值<br>阶乘不能有0，最小值为1，1的乘积还是为1</p><pre><code class="javascript">function factorial(n){ if(n === 1) return 1 return factorial(n - 1) * n}</code></pre></li><li><p>时间复杂度<br>// …</p></li></ol><p>TODO 树中到递归</p><p>求二叉树的最大深度<br>Simple inline $$a = b + c$$.<br>Simple inline $a = b + c$.</p><hr><p> \(a+b=c\)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2020/05/03/markdown-cheatsheet/"/>
    <id>http://yoursite.com/2020/05/03/markdown-cheatsheet/</id>
    <published>2020-05-03T08:10:15.000Z</published>
    <updated>2020-05-07T04:37:50.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code class="markdown"># 标题1## 标题2### 标题3标题1=====标题2-----</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code class="markdown">*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___~~删除线~~&lt;u&gt;下划线&lt;/u&gt;</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code class="markdown">---***</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code>* 无序项* 无序项+ 无序项+ 无序项- 无序项- 无序项1. 有序12. 有序2</code></pre><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><pre><code class="markdown">&gt; 这是一个&gt; 区块引用&gt; &gt; 嵌套引用</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="markdown">`foo`​```function foo(){    // 这是代码块}​```</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code class="markdown">[google](http://google.com)[google][google][google]:http://google.com&lt;http://google.com&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="markdwon">![图片裂了的文字描述](图片地址 &quot;可选标题&quot;)![图片裂了的文字描述][img][img]:图片地址</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="markdown">| 表头一 | 表头二 |---|---| 单元格 | 单元格 || 左对齐 | 居中 | 右对齐 || :---  | :---: | ---: || 单元格 | 单元格 | 单元格 |</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><pre><code>[x] 已选中[ ] 未选中- [x] 已选中- [ ] 未选中</code></pre><h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><pre><code>&lt;details&gt;  &lt;summary&gt;显示文字&lt;/summary&gt;  &lt;pre&gt;   被折叠的部分  &lt;/pre&gt;&lt;/details&gt;</code></pre><h2 id="需要转义"><a href="#需要转义" class="headerlink" title="需要转义"></a>需要转义</h2><pre><code>\`*_{ }[ ]( )#+-.!</code></pre><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><pre><code>这一句话[^1]里面有注脚，后面也有[^2][^1]:注脚内容[^2]:脚注内容</code></pre><p>公式</p><pre><code>//待补充</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;# 标题1
## 标题2
### 标题3

标题1
=====
标题2
-----&lt;/co
      
    
    </summary>
    
    
      <category term="cheat sheets" scheme="http://yoursite.com/categories/cheat-sheets/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的事件循环</title>
    <link href="http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-04-29T07:19:18.000Z</published>
    <updated>2020-05-07T02:01:46.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。</p><p>但是引擎实际上只做了几件事，它逐行运行代码，并将函数添加到堆栈中。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈是一个LIFO队列，即后进先出（Last in,First out）。</p><p>当调用一个函数时，它会被推入调用栈中。如果该函数调用另一个函数，另一个函数将位于调用栈的顶部，而这个函数执行完后 ，它会从栈中被推出，直到栈被清空。</p><p>示例</p><pre><code class="javascript">function foo(b) {  let a = 10;  return a + b + 11;}function bar(x) {  let y = 3;  return foo(x * y);}console.log(bar(7)); // 返回 42</code></pre><ul><li>执行 <code>bar</code>，并推入栈中</li><li>执行 <code>bar</code> 时导致 <code>foo</code> 被调用</li><li>执行 <code>foo</code>，将 <code>foo</code> 推入栈中</li><li>执行完 <code>foo</code>，发现 <code>foo</code> 没有什么事情可做了，将 <code>foo</code> 推出栈</li><li><code>bar</code> 执行完毕，推出栈</li></ul><h2 id="队列（Callback-Queue）"><a href="#队列（Callback-Queue）" class="headerlink" title="队列（Callback Queue）"></a>队列（Callback Queue）</h2><p>Web APIs 提供了setTimeout，DOM事件等api。</p><p>在调用setTimeout时，浏览器会启用计时器，可以理解为这是浏览器做的；一旦计时器到期，将回调函数放入CallBack Queue中，并等待执行。Ajax，DOM事件等也在这里排队。</p><h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event-Loop）"></a>事件循环（Event-Loop）</h2><p><img src="/images/javascript-event-loop.png" alt=""></p><p>有一个过程会不断检查调用栈是否为空，并且每当它为空时，它就会检查 Callback Queue 中是否有等待调用的函数。如果有的话，那么队列中的第一个函数将被调用并将其移入调用栈。如果回调队列为空，则此监视过程将无限期地继续运行。事件循环是一个持续运行的过程，它同时监视回调队列和调用栈。</p><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>ECMAScript 2015 引入了 Job Queue 的概念，Promise使用了这个队列，也是我们说的微任务。</p><p>前面 Callback Queue 中添加的任务可以被称为宏任务。</p><p>微任务优先级高于宏任务。</p><pre><code class="javascript">console.log(&#39;script start&#39;);setTimeout(function() {   console.log(&#39;setTimeout&#39;);}, 0);var promise = new Promise(function(resolve, reject) {   resolve();});promise.then(function(resolve) {   console.log(&#39;Promise1&#39;);}).then(function(resolve) {   console.log(&#39;Promise2&#39;);});console.log(&#39;script end&#39;);</code></pre><details>  <summary>打印</summary>  <pre>  script start  script end  Promise1  Promise2  setTimeout  </pre></details><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>一</p><pre><code class="javascript">setTimeout(() =&gt; console.log(&#39;setTimeout1&#39;), 0);  setTimeout(() =&gt; {                                                                    console.log(&#39;setTimeout2&#39;);    Promise.resolve().then(() =&gt; {        console.log(&#39;promise3&#39;);        Promise.resolve().then(() =&gt; {            console.log(&#39;promise4&#39;);        })        console.log(5)    })    setTimeout(() =&gt; console.log(&#39;setTimeout4&#39;), 0);  }, 0);setTimeout(() =&gt; console.log(&#39;setTimeout3&#39;), 0);  Promise.resolve().then(() =&gt; {    console.log(&#39;promise1&#39;);})</code></pre><p>二</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )    await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}async1()console.log( &#39;script start&#39; )</code></pre><p>三</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}console.log( &#39;script start&#39; )setTimeout( function () {    console.log( &#39;setTimeout&#39; )}, 0 )async1();new Promise( function ( resolve ) {    console.log( &#39;promise1&#39; )    resolve();} ).then( function () {    console.log( &#39;promise2&#39; ) } )console.log( &#39;script end&#39; )</code></pre><p>四</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; {    console.log(&quot;promise1&quot;)    resolve()})    .then(() =&gt; {        console.log(1)    })    .then(() =&gt; {        console.log(2)    })    .then(() =&gt; {        console.log(3)    })new Promise((resolve, reject) =&gt; {    console.log(&quot;promise2&quot;)    resolve()})    .then(() =&gt; {        console.log(4)    })    .then(() =&gt; {        console.log(5)    })    .then(() =&gt; {        console.log(6)    })</code></pre><p>五</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await Promise.resolve().then(() =&gt; console.log(&#39;t1p&#39;))  console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()    </code></pre><p>六</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await new Promise(resolve =&gt; {    setTimeout(() =&gt; {      console.log(&#39;t1p&#39;)      resolve()    }, 1000)  })  await console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()console.log(&#39;end&#39;)</code></pre><blockquote><p>参考：</p><p><a href="https://www.javascripttutorial.net/javascript-event-loop/" target="_blank" rel="noopener">https://www.javascripttutorial.net/javascript-event-loop/</a></p><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p><p><a href="https://www.cnblogs.com/fangdongdemao/p/10262209.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangdongdemao/p/10262209.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。&lt;/p&gt;
&lt;p&gt;但是引擎实际上只做
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>demo</title>
    <link href="http://yoursite.com/2020/04/28/demo/"/>
    <id>http://yoursite.com/2020/04/28/demo/</id>
    <published>2020-04-28T13:39:33.000Z</published>
    <updated>2020-05-03T09:26:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个demo&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
</feed>
