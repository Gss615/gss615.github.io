<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-11T04:18:23.834Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>递归</title>
    <link href="http://yoursite.com/2020/05/05/%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2020/05/05/%E9%80%92%E5%BD%92/</id>
    <published>2020-05-05T15:30:31.000Z</published>
    <updated>2020-05-11T04:18:23.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p></blockquote><p>在JavaScript中是指在函数定义中使用函数自身的方法。</p><ul><li>直接调用自己</li><li>间接调用自己</li></ul><pre><code class="javascript">function foo(){    foo()}</code></pre><p>每个递归函数都有两个部分：基线条件和递归条件。递归条件是指函数调用自己，而基线条件是指函数不再调用自己，从而避免形成无限循环。</p><h2 id="递归中的调用栈"><a href="#递归中的调用栈" class="headerlink" title="递归中的调用栈"></a>递归中的调用栈</h2><p>栈是一种后进先出的数据结构。</p><p>示例：</p><pre><code class="javascript">function foo(i) {  if (i &lt; 0) return;  console.log(&#39;begin:&#39; + i);  foo(i - 1);  console.log(&#39;end:&#39; + i);}foo(2);</code></pre><details>  <summary>打印</summary>  <pre>    begin 2    begin 1    begin 0    end 0    end 1    end 2  </pre></details><p>每当一个函数被一个算法调用时，该函数会进入调用栈的顶部。当使用递归的时候，每个函数调用都会堆叠在调用栈的顶部，这是因为每个调用都可能依赖前一个调用的结果；可以将 <code>console.trace</code> 添加到函数头部在控制台中查看。</p><pre><code class="javascript">function foo(i) {    console.trace()    if (i &lt; 0) return;    console.log(&#39;begin:&#39; + i);    foo(i - 1);    console.log(&#39;end:&#39; + i);}foo(2);</code></pre><details><summary>打印</summary><pre><code>recursion.js:67 console.tracefoo @ recursion.js:67(anonymous) @ recursion.js:73recursion.js:69 begin:2recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:69 begin:1recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:69 begin:0recursion.js:67 console.tracefoo @ recursion.js:67foo @ recursion.js:70foo @ recursion.js:70foo @ recursion.js:70(anonymous) @ recursion.js:73recursion.js:71 end:0recursion.js:71 end:1recursion.js:71 end:2</code></pre></details><p>如果递归函数中用到大量数据，或者调用栈很长，可以能会造成栈占用大量内存，解决的办法有两个：</p><ul><li>重新编写代码，使用循环</li><li>使用尾递归</li></ul><h2 id="技巧和思路"><a href="#技巧和思路" class="headerlink" title="技巧和思路"></a>技巧和思路</h2><blockquote><ol><li>先定义一个函数，明确这个函数的功能</li><li>寻找问题和自问题间的关系，也就是递推关系</li><li>寻找最终不可再分解的子问题，也就是临界值</li><li>根据问题和子问题的关系，推导时间复杂</li></ol></blockquote><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><ol><li><p>定以函数</p><pre><code class="javascript"> function factorial(n){ // TODO 计算 }</code></pre></li><li><p>寻找递推关系</p><p> 这个函数的功能是求n的阶乘，也就是 1 到 n 所有数的乘积<br> $$f(n) = n * (n - 1) * (n - 2) * (n - 3) * … * 1$$<br> 很容易看出 f(n) 和 f(n-1) 的关系为：<br> $$f(n) = f(n-1) * n$$</p></li><li><p><strong>寻找临界值</strong></p><p> 阶乘不能有0，最小值为1，1的乘积还是为1<br> $$f(1) = 1$$<br> 得出结论：<br> $$<br> f(n)=\begin{cases}<br> 1,\quad n = 1 \\<br> f(n-1) * n,\quad n &gt; 1<br> \end{cases}<br> $$<br> 将结论转换为代码：</p><pre><code class="javascript"> function factorial(n){     if(n === 1) return 1     return factorial(n - 1) * n }</code></pre></li><li><p>时间复杂度</p><p> 总共有n个子问题 O(n)；<br> 每个问题进行了一次计算 O(1)；<br> 时间复杂度为 O(n)</p></li></ol><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">青蛙跳台阶问题</a></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>提示：0 &lt;= n &lt;= 100</p><ol><li><p>定义函数 climbStairs</p><pre><code class="javascript">function climbStairs(n){ // TODO}</code></pre></li><li><p>寻找递推关系</p><p>假设跳上 n 级台阶有f(n)种跳法，在所有跳法中，青蛙的最后一步只有两种情况：跳了 1 阶或跳了 2 阶</p><ol><li>当为 1 阶台阶：剩 n - 1 个台阶，这种情况共有 f(n - 1) 种跳法；</li><li>当为 2 阶台阶：剩 n - 2 个台阶，这种情况共有 f(n - 2) 种跳法。</li></ol><p>f(n) 为以上两种情况当和，得出结论为:</p><p>$$f(n) = f(n - 1） + f(n - 2)$$</p></li><li><p>寻找临界值</p><p>n 为 0 时，f(0) = 1</p><p>n 为 1 时，f(1) = 1<br>$$<br>f(n)=\begin{cases}<br>1,\quad n = 0 \\<br>1,\quad n = 1 \\<br>f(n-1) + f(n-2),\quad n &gt; 2<br>\end{cases}<br>$$<br>将结论转换为代码</p><pre><code class="javascript">functionn climbStairs(n){  if(n === 0 || n === 1) return 1  return f(n - 1) + f(n - 2)}</code></pre></li><li><p>空间复杂度</p><p>子问题个数：climbStairs 算法形成了一个递归数，每个问题是一个节点，当前节点下形成两个节点，所以子问题的个数为O(2^n)；<br>解决一个问题的时间：递归中，每次只执行了 一个加法计算，时间为O(1)<br>所以这个算法的时间复杂度为O(2^n)，为指数级别，不可取。</p><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/" target="_blank" rel="noopener">另外还有两种方法</a></p><ul><li>记忆法递归<br>   原理：在递归法的基础上，新建一个长度为 n 的数组，用于在递归时储存f(0)到f(n)的数字只，重复遇到某数字时直接从数组取用，避免重复计算。但记忆储存需要O(n)的额外空间</li><li>动态规划<br>   以斐波那契数列性质f(n+1) = f(n) + f(n-1)为转移方程。</li></ul></li></ol><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h3><ol><li><p>定义函数 treeNode</p><pre><code>```javascriptfunction treeNode(tree){    // TODO}```</code></pre></li><li><p>寻找递推关系</p><p> 假设解决root节点的反转为 treeNode(root)；</p><pre><code class="javascript"> treeNode(node){     let left = node.right     let right = node.left     node.right = left     node.left = right     return node  }</code></pre><p> root节点又分为left，right两个节点，这两个节点分别产生两个节点，也都需要反转，子问题的子问题也是如此.</p><pre><code class="javascript"> treeNode(node){     let left = node.right     let right = node.left     node.right = treeNode(node.left)     node.left = treeNode(node.right)     return node  }</code></pre></li><li><p>寻找临界值</p><p> 如果父节点下面有子节点是，就需要反转；如果为 null 时，也就是连一个子节点都没有，也就不需要反转了。</p><pre><code class="javascript"> treeNode(node){     if(node === null) return node     let left = node.right     let right = node.left     node.right = treeNode(node.left)     node.left = treeNode(node.right)     return node  }</code></pre></li><li><p>时间复杂度</p><p> 树的每个节点都只被访问一次，时间复杂度为 O(n)</p></li></ol><blockquote><p>参考链接：</p><ul><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Leetcode</a></li><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode</a></li><li><a href="https://www.cxyxiaowu.com/7259.html" target="_blank" rel="noopener">告别递归，从零开始一文学会递归解题</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2020/05/03/markdown-cheatsheet/"/>
    <id>http://yoursite.com/2020/05/03/markdown-cheatsheet/</id>
    <published>2020-05-03T08:10:15.000Z</published>
    <updated>2020-05-07T04:37:50.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code class="markdown"># 标题1## 标题2### 标题3标题1=====标题2-----</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code class="markdown">*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___~~删除线~~&lt;u&gt;下划线&lt;/u&gt;</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code class="markdown">---***</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code>* 无序项* 无序项+ 无序项+ 无序项- 无序项- 无序项1. 有序12. 有序2</code></pre><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><pre><code class="markdown">&gt; 这是一个&gt; 区块引用&gt; &gt; 嵌套引用</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="markdown">`foo`​```function foo(){    // 这是代码块}​```</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code class="markdown">[google](http://google.com)[google][google][google]:http://google.com&lt;http://google.com&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="markdwon">![图片裂了的文字描述](图片地址 &quot;可选标题&quot;)![图片裂了的文字描述][img][img]:图片地址</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="markdown">| 表头一 | 表头二 |---|---| 单元格 | 单元格 || 左对齐 | 居中 | 右对齐 || :---  | :---: | ---: || 单元格 | 单元格 | 单元格 |</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><pre><code>[x] 已选中[ ] 未选中- [x] 已选中- [ ] 未选中</code></pre><h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><pre><code>&lt;details&gt;  &lt;summary&gt;显示文字&lt;/summary&gt;  &lt;pre&gt;   被折叠的部分  &lt;/pre&gt;&lt;/details&gt;</code></pre><h2 id="需要转义"><a href="#需要转义" class="headerlink" title="需要转义"></a>需要转义</h2><pre><code>\`*_{ }[ ]( )#+-.!</code></pre><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><pre><code>这一句话[^1]里面有注脚，后面也有[^2][^1]:注脚内容[^2]:脚注内容</code></pre><p>公式</p><pre><code>//待补充</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;# 标题1
## 标题2
### 标题3

标题1
=====
标题2
-----&lt;/co
      
    
    </summary>
    
    
      <category term="cheat sheets" scheme="http://yoursite.com/categories/cheat-sheets/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的事件循环</title>
    <link href="http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-04-29T07:19:18.000Z</published>
    <updated>2020-05-07T02:01:46.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。</p><p>但是引擎实际上只做了几件事，它逐行运行代码，并将函数添加到堆栈中。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈是一个LIFO队列，即后进先出（Last in,First out）。</p><p>当调用一个函数时，它会被推入调用栈中。如果该函数调用另一个函数，另一个函数将位于调用栈的顶部，而这个函数执行完后 ，它会从栈中被推出，直到栈被清空。</p><p>示例</p><pre><code class="javascript">function foo(b) {  let a = 10;  return a + b + 11;}function bar(x) {  let y = 3;  return foo(x * y);}console.log(bar(7)); // 返回 42</code></pre><ul><li>执行 <code>bar</code>，并推入栈中</li><li>执行 <code>bar</code> 时导致 <code>foo</code> 被调用</li><li>执行 <code>foo</code>，将 <code>foo</code> 推入栈中</li><li>执行完 <code>foo</code>，发现 <code>foo</code> 没有什么事情可做了，将 <code>foo</code> 推出栈</li><li><code>bar</code> 执行完毕，推出栈</li></ul><h2 id="队列（Callback-Queue）"><a href="#队列（Callback-Queue）" class="headerlink" title="队列（Callback Queue）"></a>队列（Callback Queue）</h2><p>Web APIs 提供了setTimeout，DOM事件等api。</p><p>在调用setTimeout时，浏览器会启用计时器，可以理解为这是浏览器做的；一旦计时器到期，将回调函数放入CallBack Queue中，并等待执行。Ajax，DOM事件等也在这里排队。</p><h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event-Loop）"></a>事件循环（Event-Loop）</h2><p><img src="/images/javascript-event-loop.png" alt=""></p><p>有一个过程会不断检查调用栈是否为空，并且每当它为空时，它就会检查 Callback Queue 中是否有等待调用的函数。如果有的话，那么队列中的第一个函数将被调用并将其移入调用栈。如果回调队列为空，则此监视过程将无限期地继续运行。事件循环是一个持续运行的过程，它同时监视回调队列和调用栈。</p><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>ECMAScript 2015 引入了 Job Queue 的概念，Promise使用了这个队列，也是我们说的微任务。</p><p>前面 Callback Queue 中添加的任务可以被称为宏任务。</p><p>微任务优先级高于宏任务。</p><pre><code class="javascript">console.log(&#39;script start&#39;);setTimeout(function() {   console.log(&#39;setTimeout&#39;);}, 0);var promise = new Promise(function(resolve, reject) {   resolve();});promise.then(function(resolve) {   console.log(&#39;Promise1&#39;);}).then(function(resolve) {   console.log(&#39;Promise2&#39;);});console.log(&#39;script end&#39;);</code></pre><details>  <summary>打印</summary>  <pre>  script start  script end  Promise1  Promise2  setTimeout  </pre></details><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>一</p><pre><code class="javascript">setTimeout(() =&gt; console.log(&#39;setTimeout1&#39;), 0);  setTimeout(() =&gt; {                                                                    console.log(&#39;setTimeout2&#39;);    Promise.resolve().then(() =&gt; {        console.log(&#39;promise3&#39;);        Promise.resolve().then(() =&gt; {            console.log(&#39;promise4&#39;);        })        console.log(5)    })    setTimeout(() =&gt; console.log(&#39;setTimeout4&#39;), 0);  }, 0);setTimeout(() =&gt; console.log(&#39;setTimeout3&#39;), 0);  Promise.resolve().then(() =&gt; {    console.log(&#39;promise1&#39;);})</code></pre><p>二</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )    await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}async1()console.log( &#39;script start&#39; )</code></pre><p>三</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}console.log( &#39;script start&#39; )setTimeout( function () {    console.log( &#39;setTimeout&#39; )}, 0 )async1();new Promise( function ( resolve ) {    console.log( &#39;promise1&#39; )    resolve();} ).then( function () {    console.log( &#39;promise2&#39; ) } )console.log( &#39;script end&#39; )</code></pre><p>四</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; {    console.log(&quot;promise1&quot;)    resolve()})    .then(() =&gt; {        console.log(1)    })    .then(() =&gt; {        console.log(2)    })    .then(() =&gt; {        console.log(3)    })new Promise((resolve, reject) =&gt; {    console.log(&quot;promise2&quot;)    resolve()})    .then(() =&gt; {        console.log(4)    })    .then(() =&gt; {        console.log(5)    })    .then(() =&gt; {        console.log(6)    })</code></pre><p>五</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await Promise.resolve().then(() =&gt; console.log(&#39;t1p&#39;))  console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()    </code></pre><p>六</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await new Promise(resolve =&gt; {    setTimeout(() =&gt; {      console.log(&#39;t1p&#39;)      resolve()    }, 1000)  })  await console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()console.log(&#39;end&#39;)</code></pre><blockquote><p>参考：</p><p><a href="https://www.javascripttutorial.net/javascript-event-loop/" target="_blank" rel="noopener">https://www.javascripttutorial.net/javascript-event-loop/</a></p><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p><p><a href="https://www.cnblogs.com/fangdongdemao/p/10262209.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangdongdemao/p/10262209.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。&lt;/p&gt;
&lt;p&gt;但是引擎实际上只做
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
