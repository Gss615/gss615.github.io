<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-03T21:36:20.281Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2020/05/03/markdown-cheatsheet/"/>
    <id>http://yoursite.com/2020/05/03/markdown-cheatsheet/</id>
    <published>2020-05-03T08:10:15.000Z</published>
    <updated>2020-05-03T21:36:20.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code class="markdown"># 标题1## 标题2### 标题3标题1=====标题2-----</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code class="markdown">*斜体*_斜体_**粗体**__粗体__***粗斜体***___粗斜体___~~删除线~~&lt;u&gt;下划线&lt;/u&gt;</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code class="markdown">---***</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code>* 无序项* 无序项+ 无序项+ 无序项- 无序项- 无序项1. 有序12. 有序2</code></pre><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><pre><code class="markdown">&gt; 这是一个&gt; 区块引用&gt; &gt; 嵌套引用</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="markdown">`foo`​```function foo(){    // 这是代码块}​```</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code class="markdown">[google](http://google.com)[google][google][google]:http://google.com&lt;http://google.com&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="markdwon">![图片裂了的文字描述](图片地址 &quot;可选标题&quot;)![图片裂了的文字描述][img][img]:图片地址</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="markdown">| 表头一 | 表头二 |---|---| 单元格 | 单元格 || 左对齐 | 居中 | 右对齐 || :---  | :---: | ---: || 单元格 | 单元格 | 单元格 |</code></pre><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><pre><code>[x] 已选中[ ] 未选中- [x] 已选中- [ ] 未选中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;# 标题1
## 标题2
### 标题3

标题1
=====
标题2
-----&lt;/co
      
    
    </summary>
    
    
      <category term="cheat sheets" scheme="http://yoursite.com/categories/cheat-sheets/"/>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的事件循环</title>
    <link href="http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/04/29/javascript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-04-29T07:19:18.000Z</published>
    <updated>2020-05-03T07:32:26.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。</p><p>但是引擎实际上只做了几件事，它逐行运行代码，并将函数添加到堆栈中。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>调用栈是一个LIFO队列，即后进先出（Last in,First out）。</p><p>当调用一个函数时，它会被推入调用栈中。如果该函数调用另一个函数，另一个函数将位于调用栈的顶部，而这个函数执行完后 ，它会从栈中被推出，直到栈被清空。</p><p>示例</p><pre><code class="javascript">function foo(b) {  let a = 10;  return a + b + 11;}function bar(x) {  let y = 3;  return foo(x * y);}console.log(bar(7)); // 返回 42</code></pre><ul><li>执行 <code>bar</code>，并推入栈中</li><li>执行 <code>bar</code> 时导致 <code>foo</code> 被调用</li><li>执行 <code>foo</code>，将 <code>foo</code> 推入栈中</li><li>执行完 <code>foo</code>，发现 <code>foo</code> 没有什么事情可做了，将 <code>foo</code> 推出栈</li><li><code>bar</code> 执行完毕，推出栈</li></ul><h2 id="队列（Callback-Queue）"><a href="#队列（Callback-Queue）" class="headerlink" title="队列（Callback Queue）"></a>队列（Callback Queue）</h2><p>Web APIs 提供了setTimeout，DOM事件等api。</p><p>在调用setTimeout时，浏览器会启用计时器，可以理解为这是浏览器做的；一旦计时器到期，将回调函数放入CallBack Queue中，并等待执行。Ajax，DOM事件等也在这里排队。</p><h2 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event-Loop）"></a>事件循环（Event-Loop）</h2><p><img src="/images/javascript-event-loop.png" alt=""></p><p>有一个过程会不断检查调用栈是否为空，并且每当它为空时，它就会检查 Callback Queue 中是否有等待调用的函数。如果有的话，那么队列中的第一个函数将被调用并将其移入调用栈。如果回调队列为空，则此监视过程将无限期地继续运行。事件循环是一个持续运行的过程，它同时监视回调队列和调用栈。</p><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>ECMAScript 2015 引入了 Job Queue 的概念，Promise使用了这个队列，也是我们说的微任务。</p><p>前面 Callback Queue 中添加的任务可以被称为宏任务。</p><p>微任务优先级高于宏任务。</p><pre><code class="javascript">console.log(&#39;script start&#39;);setTimeout(function() {   console.log(&#39;setTimeout&#39;);}, 0);var promise = new Promise(function(resolve, reject) {   resolve();});promise.then(function(resolve) {   console.log(&#39;Promise1&#39;);}).then(function(resolve) {   console.log(&#39;Promise2&#39;);});console.log(&#39;script end&#39;);</code></pre><details>  <summary>打印</summary>  <pre>  script start  script end  Promise1  Promise2  setTimeout  </pre></details><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>一</p><pre><code class="javascript">setTimeout(() =&gt; console.log(&#39;setTimeout1&#39;), 0);  setTimeout(() =&gt; {                                                                    console.log(&#39;setTimeout2&#39;);    Promise.resolve().then(() =&gt; {        console.log(&#39;promise3&#39;);        Promise.resolve().then(() =&gt; {            console.log(&#39;promise4&#39;);        })        console.log(5)    })    setTimeout(() =&gt; console.log(&#39;setTimeout4&#39;), 0);  }, 0);setTimeout(() =&gt; console.log(&#39;setTimeout3&#39;), 0);  Promise.resolve().then(() =&gt; {    console.log(&#39;promise1&#39;);})</code></pre><p>二</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )    await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}async1()console.log( &#39;script start&#39; )</code></pre><p>三</p><pre><code class="javascript">async function async1() {    console.log( &#39;async1 start&#39; )await async2()    console.log( &#39;async1 end&#39; )}async function async2() {    console.log( &#39;async2&#39; )}console.log( &#39;script start&#39; )setTimeout( function () {    console.log( &#39;setTimeout&#39; )}, 0 )async1();new Promise( function ( resolve ) {    console.log( &#39;promise1&#39; )    resolve();} ).then( function () {    console.log( &#39;promise2&#39; ) } )console.log( &#39;script end&#39; )</code></pre><p>四</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; {    console.log(&quot;promise1&quot;)    resolve()})    .then(() =&gt; {        console.log(1)    })    .then(() =&gt; {        console.log(2)    })    .then(() =&gt; {        console.log(3)    })new Promise((resolve, reject) =&gt; {    console.log(&quot;promise2&quot;)    resolve()})    .then(() =&gt; {        console.log(4)    })    .then(() =&gt; {        console.log(5)    })    .then(() =&gt; {        console.log(6)    })</code></pre><p>五</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await Promise.resolve().then(() =&gt; console.log(&#39;t1p&#39;))  console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()    </code></pre><p>六</p><pre><code class="javascript">async function t1 () {  console.log(1)  console.log(2)  await new Promise(resolve =&gt; {    setTimeout(() =&gt; {      console.log(&#39;t1p&#39;)      resolve()    }, 1000)  })  await console.log(3)  console.log(4)}async function t2() {  console.log(5)  console.log(6)  await Promise.resolve().then(() =&gt; console.log(&#39;t2p&#39;))  console.log(7)  console.log(8)}t1()t2()console.log(&#39;end&#39;)</code></pre><blockquote><p>参考：</p><p><a href="https://www.javascripttutorial.net/javascript-event-loop/" target="_blank" rel="noopener">https://www.javascripttutorial.net/javascript-event-loop/</a></p><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p><p><a href="https://www.cnblogs.com/fangdongdemao/p/10262209.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangdongdemao/p/10262209.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;JavaScript是一个单线程语言，它由各种引擎解释，其中最著名的是Chrome和Node中使用的V8。&lt;/p&gt;
&lt;p&gt;但是引擎实际上只做
      
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>demo</title>
    <link href="http://yoursite.com/2020/04/28/demo/"/>
    <id>http://yoursite.com/2020/04/28/demo/</id>
    <published>2020-04-28T13:39:33.000Z</published>
    <updated>2020-05-03T09:26:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个demo&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
</feed>
